import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import { setupAuth } from "./auth";
import { hashPassword } from "./auth";
import { z } from "zod";
import { insertBookingSchema } from "@shared/schema";
import { insertUserSchema } from "@shared/schema";
import { db, pool } from "./db";
import { sql } from "drizzle-orm";

// Schema untuk permintaan booking publik
const publicBookingSchema = z.object({
  meetingTitle: z.string().min(3, "Judul harus minimal 3 karakter"),
  meetingDate: z.string().min(1, "Tanggal wajib diisi"),
  startTime: z.string().min(1, "Waktu mulai wajib diisi"),
  endTime: z.string().min(1, "Waktu selesai wajib diisi"),
  participants: z.coerce.number().min(1, "Minimal 1 peserta diperlukan"),
  purpose: z.string().min(5, "Tujuan harus minimal 5 karakter"),
  kodeTiket: z.string().min(1, "Kode Tiket wajib diisi")
});

export async function registerRoutes(app: Express): Promise<Server> {
  // Setup authentication routes
  setupAuth(app);
  
  // Authentication middleware
  const authenticateUser = (req: Request, res: Response, next: NextFunction) => {
    if (!req.isAuthenticated() || !req.user) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    next();
  };
  
  // Admin middleware
  const authenticateAdmin = (req: Request, res: Response, next: NextFunction) => {
    if (!req.isAuthenticated() || !req.user) {
      return res.status(401).json({ message: "Unauthorized" });
    }
    
    console.log('Admin check - User:', { 
      id: req.user.id, 
      username_ldap: req.user.username_ldap, 
      role_id: req.user.role_id,
      role_id_type: typeof req.user.role_id
    });
    
    if (req.user.role_id != 1) { // Menggunakan perbandingan longgar (==) karena mungkin tipe datanya berbeda
      console.log('Access denied - role_id is not 1');
      return res.status(403).json({ message: "Akses ditolak, hak akses admin diperlukan" });
    }
    
    console.log('Admin access granted');
    next();
  };

  // API routes for Zoom account management
  
  // Get all Zoom accounts with their status
  app.get("/api/zoom-accounts", authenticateUser, async (req, res, next) => {
    try {
      const accounts = await storage.getAllZoomAccounts();
      res.json(accounts);
    } catch (error) {
      next(error);
    }
  });
  
  // Get a specific Zoom account
  app.get("/api/zoom-accounts/:id", async (req, res, next) => {
    try {
      if (!req.isAuthenticated() || !req.user) return res.status(401).json({ message: "Unauthorized" });
      
      const id = parseInt(req.params.id);
      const account = await storage.getZoomAccount(id);
      
      if (!account) {
        return res.status(404).json({ message: "Zoom account not found" });
      }
      
      res.json(account);
    } catch (error) {
      next(error);
    }
  });
  
  // Bookings routes
  
  // Create a new booking
  app.post("/api/bookings", async (req, res, next) => {
    try {
      if (!req.isAuthenticated() || !req.user) return res.status(401).json({ message: "Unauthorized" });
      
      // Get the user data
      const user = await storage.getUser(req.user.id);
      if (!user) return res.status(404).json({ message: "User not found" });
      
      // Validate request body
      const validatedData = insertBookingSchema.parse({
        ...req.body,
        userId: req.user.id,
        // User ID sudah ditambahkan di atas
      });
      
      // Validasi jadwal tidak boleh kurang dari waktu saat ini
      const now = new Date();
      const meetingDateTime = new Date(`${validatedData.meetingDate} ${validatedData.startTime}`);
      
      if (meetingDateTime < now) {
        return res.status(400).json({ 
          success: false,
          message: "Tidak dapat membuat booking. Waktu mulai rapat tidak boleh kurang dari waktu saat ini." 
        });
      }
      
      // Create the booking (will only be created if Zoom account is available)
      const { booking, zoomAccount } = await storage.createBooking(validatedData);
      
      if (!booking || !zoomAccount) {
        return res.status(400).json({ 
          success: false,
          message: "Tidak ada akun Zoom yang tersedia, silakan coba jadwal lain atau hubungi admin." 
        });
      }
      
      // Return the booking and zoom account details
      res.status(201).json({ 
        success: true,
        booking, 
        zoomAccount 
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid booking data", errors: error.errors });
      }
      next(error);
    }
  });
  
  // Endpoint untuk mendapatkan data pegawai berdasarkan ID
  app.get("/api/pegawai/:id", async (req, res, next) => {
    try {
      const pegawaiId = parseInt(req.params.id);
      if (isNaN(pegawaiId)) {
        return res.status(400).json({ success: false, message: "ID Pegawai tidak valid" });
      }
      
      const pegawai = await storage.getPegawaiById(pegawaiId);
      if (!pegawai) {
        return res.status(404).json({ success: false, message: "Pegawai tidak ditemukan" });
      }
      
      res.status(200).json({ success: true, pegawai });
    } catch (error) {
      next(error);
    }
  });
  
  // Endpoint untuk validasi kode tiket
  app.get("/api/validate-tiket/:kode", async (req, res, next) => {
    try {
      const kodeTiket = req.params.kode;
      if (!kodeTiket) {
        return res.status(400).json({ success: false, message: "Kode tiket tidak valid" });
      }
      
      // Periksa kode tiket dan dapatkan data pegawai
      const [rows] = await pool.query(
        `SELECT t.*, p.nama as nama_pegawai 
         FROM tiket t 
         LEFT JOIN pegawai p ON t.pemohon_id = p.id 
         WHERE t.kode_tiket = ?`, 
        [kodeTiket]
      ) as any;
      
      const ticketData = Array.isArray(rows) && rows.length > 0 ? rows[0] : null;
      const isValid = !!ticketData;
      
      res.status(200).json({ 
        success: true, 
        isValid,
        employeeName: ticketData?.nama_pegawai || null
      });
    } catch (error) {
      console.error('Error validating ticket code:', error);
      res.status(500).json({ success: false, message: "Terjadi kesalahan saat validasi kode tiket" });
    }
  });
  
  // Endpoint untuk permintaan booking publik (tidak memerlukan autentikasi)
  app.post("/api/public-bookings", async (req, res, next) => {
    try {
      // Validate request body
      const validatedData = publicBookingSchema.parse(req.body);
      
      // Validasi jadwal tidak boleh kurang dari waktu saat ini
      const now = new Date();
      const meetingDateTime = new Date(`${validatedData.meetingDate} ${validatedData.startTime}`);
      
      if (meetingDateTime < now) {
        return res.status(400).json({ 
          success: false,
          message: "Tidak dapat membuat booking. Waktu mulai rapat tidak boleh kurang dari waktu saat ini." 
        });
      }
      
      // Dapatkan data tiket untuk mendapatkan pemohon_id
      const [ticketRows] = await pool.query(
        `SELECT * FROM tiket WHERE kode_tiket = ?`, 
        [validatedData.kodeTiket]
      ) as any;
      
      if (!Array.isArray(ticketRows) || ticketRows.length === 0) {
        return res.status(400).json({ 
          success: false,
          message: "Kode tiket tidak valid atau tidak ditemukan." 
        });
      }
      
      const ticketData = ticketRows[0];
      
      // Buat objek booking dengan pemohon_id sebagai userId dan kode_tiket dalam field terpisah
      const bookingData = {
        meetingTitle: validatedData.meetingTitle,
        meetingDate: validatedData.meetingDate,
        startTime: validatedData.startTime,
        endTime: validatedData.endTime,
        participants: validatedData.participants,
        purpose: validatedData.purpose,
        userId: ticketData.pemohon_id, // Ambil pemohon_id dari data tiket
        kode_tiket: validatedData.kodeTiket // Simpan kode_tiket di field kode_tiket
      };
      
      // Create the booking
      const { booking, zoomAccount } = await storage.createBooking(bookingData);
      
      if (!booking || !zoomAccount) {
        return res.status(400).json({ 
          success: false,
          message: "Tidak ada akun Zoom yang tersedia, silakan coba jadwal lain atau hubungi admin." 
        });
      }
      
      // Return the booking and zoom account details
      res.status(201).json({ 
        success: true,
        booking, 
        zoomAccount 
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid booking data", errors: error.errors });
      }
      next(error);
    }
  });
  
  // Get all bookings for the current user
  app.get("/api/bookings", async (req, res, next) => {
    try {
      await markCompletedBookings();
      if (!req.isAuthenticated() || !req.user) return res.status(401).json({ message: "Unauthorized" });
      
      const userBookings = await storage.getBookingsByUserId(req.user.id);
      
      // Enhance bookings with Zoom account details if assigned
      const enhancedBookings = await Promise.all(
        userBookings.map(async (booking) => {
          if (booking.zoomAccountId) {
            const zoomAccount = await storage.getZoomAccount(booking.zoomAccountId);
            return { 
              ...booking, 
              zoomAccount: zoomAccount || null 
            };
          }
          return { ...booking, zoomAccount: null };
        })
      );
      
      res.json(enhancedBookings);
    } catch (error) {
      next(error);
    }
  });
  
  // Get a specific booking
  app.get("/api/bookings/:id", async (req, res, next) => {
    try {
      if (!req.isAuthenticated() || !req.user) return res.status(401).json({ message: "Unauthorized" });
      
      const id = parseInt(req.params.id);
      const booking = await storage.getBooking(id);
      
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      
      // Only allow users to view their own bookings
      if (booking.userId !== req.user.id) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      // Include Zoom account details if assigned
      let zoomAccount = null;
      if (booking.zoomAccountId) {
        zoomAccount = await storage.getZoomAccount(booking.zoomAccountId);
      }
      
      res.json({ booking, zoomAccount });
    } catch (error) {
      next(error);
    }
  });
  
  // Cancel a booking
  app.delete("/api/bookings/:id", async (req, res, next) => {
    try {
      if (!req.isAuthenticated() || !req.user) return res.status(401).json({ message: "Unauthorized" });
      
      const id = parseInt(req.params.id);
      const booking = await storage.getBooking(id);
      
      if (!booking) {
        return res.status(404).json({ message: "Booking not found" });
      }
      
      // Only allow users to cancel their own bookings
      if (booking.userId !== req.user.id) {
        return res.status(403).json({ message: "Forbidden" });
      }
      
      // Update booking status to cancelled
      const updatedBooking = await storage.updateBooking(id, { status: "cancelled" });
      
      res.json(updatedBooking);
    } catch (error) {
      next(error);
    }
  });
  
  // Admin routes
  
  // Get admin dashboard stats
  app.get("/api/admin/stats", authenticateAdmin, async (req, res, next) => {
    try {
      await markCompletedBookings();
      const allUsers = await storage.getAllUsers();
      const allZoomAccounts = await storage.getAllZoomAccounts();
      const allBookings = await storage.getAllBookings();
      
      const activeZoomAccounts = allZoomAccounts.filter(acc => acc.isActive);
      const inactiveZoomAccounts = allZoomAccounts.filter(acc => !acc.isActive);
      const pendingBookings = allBookings.filter(booking => booking.status === "pending");
      const completedBookings = allBookings.filter(booking => booking.status === "completed");
      
      // Get accounts with their status
      const accountsWithStatus = allZoomAccounts.map(account => ({
        id: account.id,
        name: account.name,
        username: account.username,
        isActive: account.isActive
      }));

      // Get latest bookings with zoom account info
      const latestBookings = await Promise.all(
        allBookings.slice(0, 5).map(async (booking) => ({
          id: booking.id,
          meetingTitle: booking.meetingTitle,
          meetingDate: booking.meetingDate,
          startTime: booking.startTime,
          endTime: booking.endTime,
          status: booking.status,
          zoomAccount: booking.zoomAccountId 
            ? await storage.getZoomAccount(booking.zoomAccountId)
            : undefined
        }))
      );

      // Get users with department and role
      if (!req.user) return res.status(401).json({ message: "Unauthorized" });
      const users = allUsers.map(user => ({
        id: user.id,
        name: user.name,
        username: user.username_ldap,
        department: user.department,
        role: user.role_id // Tetap gunakan nama properti 'role' untuk kompatibilitas dengan client
      }));

      res.json({
        totalBookings: allBookings.length,
        totalUsers: allUsers.length,
        activeZoomAccounts: activeZoomAccounts.length,
        inactiveZoomAccounts: inactiveZoomAccounts.length,
        pendingBookings: pendingBookings.length,
        completedBookings: completedBookings.length,
        accountsWithStatus,
        latestBookings,
        users
      });
    } catch (error) {
      next(error);
    }
  });
  
  // Create new user (admin only)
  app.post("/api/admin/users", authenticateAdmin, async (req, res, next) => {
    try {
      // Validate request body
      const validatedData = insertUserSchema.parse(req.body);
      // Hash password sebelum simpan
      const hashedPassword = await hashPassword(validatedData.password);
      const user = await storage.createUser({
        ...validatedData,
        password: hashedPassword,
      });
      res.status(201).json(user);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ 
          message: "Invalid user data", 
          errors: error.errors 
        });
      }
      next(error);
    }
  });
  
  // Hapus user (admin only)
  app.delete("/api/admin/users/:id", authenticateAdmin, async (req, res, next) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) return res.status(400).json({ message: "ID tidak valid" });
      const user = await storage.getUser(id);
      if (!user) return res.status(404).json({ message: "User tidak ditemukan" });
      await storage.deleteUser(id);
      res.status(204).send();
    } catch (error) {
      next(error);
    }
  });
  
  // User dashboard stats
  app.get("/api/dashboard", authenticateUser, async (req, res, next) => {
    try {
      const allAccounts = await storage.getAllZoomAccounts();
      const allBookings = await storage.getAllBookings();
      const userBookings = await storage.getBookingsByUserId(req.user.id);
      
      // Get currently active bookings (assuming they are for today)
      const today = new Date().toISOString().split('T')[0];
      const activeBookings = allBookings.filter(booking => 
        booking.status === "confirmed" && booking.meetingDate === today
      );
      
      // Get accounts with status (calculate if they are currently booked)
      const accountsWithStatus = await Promise.all(
        allAccounts.map(async (account) => {
          const isBooked = activeBookings.some(booking => booking.zoomAccountId === account.id);
          return {
            ...account,
            currentStatus: isBooked ? "in-use" : "available"
          };
        })
      );
      
      // Calculate available accounts count
      const availableAccountsCount = accountsWithStatus.filter(
        account => account.currentStatus === "available" && account.isActive
      ).length;
      
      // Calculate currently booked accounts count
      const bookedAccountsCount = accountsWithStatus.filter(
        account => account.currentStatus === "in-use"
      ).length;
      
      // Calculate user's active bookings count
      const userActiveBookingsCount = userBookings.filter(
        booking => booking.status === "confirmed" && booking.meetingDate >= today
      ).length;
      
      const stats = {
        availableAccountsCount,
        bookedAccountsCount,
        userActiveBookingsCount,
        accountsWithStatus,
      };
      
      res.json(stats);
    } catch (error) {
      next(error);
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}

async function markCompletedBookings() {
  // Implementasi fungsi markCompletedBookings
  // Contoh:
  const allBookings = await storage.getAllBookings();
  const today = new Date().toISOString().split('T')[0];
  const completedBookings = allBookings.filter(booking => 
    booking.status === "confirmed" && booking.meetingDate < today
  );
  await Promise.all(
    completedBookings.map(async (booking) => {
      await storage.updateBooking(booking.id, { status: "completed" });
    })
  );
}
